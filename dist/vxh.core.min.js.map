{"version":3,"sources":["vxh.core.js"],"names":["$vxh","_rules","required","message","pattern","memoize","func","cache","attr","hasOwnProperty","parseRuleAttribute","split","reduce","r","str","replace","length","_str$split","_str$split2","_slicedToArray","name","args","undefined","parseMessageAttribute","_str$split3","_str$split4","rule","rules","Object","keys","forEach","ruleName","validate","elem","_execute","validityMap","valueMissing","patternMismatch","validity","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","prop","value","err","return","ruleAttributes","getAttribute","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_rules$_ruleName","ruleArgs","apply","concat","_toConsumableArray","console","error","execute","_execute2","params","v","i","tag","format"],"mappings":"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","file":"vxh.core.min.js","sourcesContent":["const $vxh = (function(){\n\n    const _rules = {\n        required: {\n            message: '入力必須です',\n        },\n        pattern: {\n            message: '入力値のパターンが正しくありません',\n        },\n\n        // rule: {\n        //     validate (elem, arg1, arg2) {\n        //         return true or false;\n        //     },\n        //\n        //     params: ['arg1', 'arg2'],\n        //\n        //     message: 'エラーメッセージ ${arg1} ${arg2}',\n        //     message (elem, arg1, arg2) {\n        //         return `エラーメッセージ ${arg1} ${arg2}`;\n        //     },\n        // }\n    };\n\n    function rule(rules) {\n        Object.keys(rules).forEach((ruleName) => {\n            _rules[ruleName] = rules[ruleName]\n        });\n    }\n\n    function memoize(func) {\n        return (function(){\n            const cache = {};\n            return function(attr){\n                if (!attr) {\n                    return {};\n                }\n                if (!cache.hasOwnProperty(attr)) {\n                    cache[attr] = func(attr);\n                }\n                return cache[attr];\n            };\n        }());\n    }\n\n    const parseRuleAttribute = memoize((attr) => {\n        return attr.split(';').reduce((r, str) => {\n            str = str.replace(/^\\s+/, '');\n            if (str.length === 0) {\n                return r;\n            }\n            const [name, args] = str.split(':', 2);\n            if (args === undefined) {\n                r[name] = [];\n            } else {\n                r[name] = args.split(',');\n            }\n            return r;\n        }, {});\n    });\n\n    const parseMessageAttribute = memoize((attr)  => {\n        return attr.split(';').reduce((r, str) => {\n            str = str.replace(/^\\s+/, '');\n            if (str.length === 0) {\n                return r;\n            }\n            const [name, message] = str.split(':', 2);\n            if (message === undefined) {\n                return r;\n            }\n            r[name] = message;\n            return r;\n        }, {});\n    });\n\n    function execute(elem) {\n\n        const validityMap = {\n            valueMissing: 'required',\n            patternMismatch: 'pattern',\n        };\n\n        if (elem.validity) {\n            for (let prop of Object.keys(validityMap)) {\n                if (elem.validity[prop]) {\n                    const ruleName = validityMap[prop];\n                    return [ruleName, []];\n                }\n            }\n        }\n\n        const ruleAttributes = parseRuleAttribute(elem.getAttribute('data-vx-rule'));\n\n        for (let ruleName of Object.keys(ruleAttributes)) {\n            if (!_rules[ruleName] || !_rules[ruleName].validate) {\n                console.error(`undefined rule.validate \"${ruleName}\"`);\n                continue;\n            }\n            const ruleArgs = ruleAttributes[ruleName];\n            const ok = _rules[ruleName].validate(elem, ...ruleArgs);\n            if (ok) {\n                continue;\n            }\n\n            return [ruleName, ruleArgs];\n        }\n\n        return [null, []];\n    }\n\n    function format(elem, ruleName, ruleArgs, message) {\n\n        if (typeof message === 'function') {\n            return message(elem, ...ruleArgs);\n        }\n\n        if (ruleArgs.length === 0) {\n            return message;\n        }\n\n        const params = {};\n\n        ruleArgs.forEach((v, i) => {\n            if (ruleArgs[i] !== undefined) {\n                params[i] = ruleArgs[i];\n            }\n        });\n\n        if (_rules[ruleName] && _rules[ruleName].params) {\n            _rules[ruleName].params.forEach((v, i) => {\n                if (ruleArgs[i] !== undefined) {\n                    params[v] = ruleArgs[i];\n                }\n            });\n        }\n\n        return message.replace(/\\${(\\w+)}/g, (str, tag)=>{\n            if (params.hasOwnProperty(tag)) {\n                return params[tag];\n            }\n            return str;\n        });\n    }\n\n    function validate(elem) {\n\n        const [ruleName, args] = execute(elem);\n        if (!ruleName) {\n            return '';\n        }\n\n        const messages = parseMessageAttribute(elem.getAttribute('data-vx-message'));\n        const message = messages[ruleName] || _rules[ruleName].message || `error:${ruleName}`;\n        return format(elem, ruleName, args, message);\n    }\n\n    return {\n        rule,\n        validate,\n    };\n}());\n"]}