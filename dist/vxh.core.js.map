{"version":3,"sources":["vxh.core.js"],"names":["$vxh","_rules","required","message","pattern","rule","rules","Object","keys","forEach","ruleName","memoize","func","cache","attr","hasOwnProperty","parseRuleAttribute","split","reduce","r","str","replace","length","name","args","undefined","parseMessageAttribute","execute","elem","validityMap","valueMissing","patternMismatch","validity","prop","ruleAttributes","getAttribute","validate","console","error","ruleArgs","ok","format","params","v","i","tag","messages"],"mappings":"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","file":"vxh.core.js","sourcesContent":["const $vxh = (function(){\n\n    const _rules = {\n        required: {\n            message: '入力必須です',\n        },\n        pattern: {\n            message: '入力値のパターンが正しくありません',\n        },\n\n        // rule: {\n        //     validate (elem, arg1, arg2) {\n        //         return true or false;\n        //     },\n        //\n        //     params: ['arg1', 'arg2'],\n        //\n        //     message: 'エラーメッセージ ${arg1} ${arg2}',\n        //     message (elem, arg1, arg2) {\n        //         return `エラーメッセージ ${arg1} ${arg2}`;\n        //     },\n        // }\n    };\n\n    function rule(rules) {\n        Object.keys(rules).forEach((ruleName) => {\n            _rules[ruleName] = rules[ruleName]\n        });\n    }\n\n    function memoize(func) {\n        return (function(){\n            const cache = {};\n            return function(attr){\n                if (!attr) {\n                    return {};\n                }\n                if (!cache.hasOwnProperty(attr)) {\n                    cache[attr] = func(attr);\n                }\n                return cache[attr];\n            };\n        }());\n    }\n\n    const parseRuleAttribute = memoize((attr) => {\n        return attr.split(';').reduce((r, str) => {\n            str = str.replace(/^\\s+/, '');\n            if (str.length === 0) {\n                return r;\n            }\n            const [name, args] = str.split(':', 2);\n            if (args === undefined) {\n                r[name] = [];\n            } else {\n                r[name] = args.split(',');\n            }\n            return r;\n        }, {});\n    });\n\n    const parseMessageAttribute = memoize((attr)  => {\n        return attr.split(';').reduce((r, str) => {\n            str = str.replace(/^\\s+/, '');\n            if (str.length === 0) {\n                return r;\n            }\n            const [name, message] = str.split(':', 2);\n            if (message === undefined) {\n                return r;\n            }\n            r[name] = message;\n            return r;\n        }, {});\n    });\n\n    function execute(elem) {\n\n        const validityMap = {\n            valueMissing: 'required',\n            patternMismatch: 'pattern',\n        };\n\n        if (elem.validity) {\n            for (let prop of Object.keys(validityMap)) {\n                if (elem.validity[prop]) {\n                    const ruleName = validityMap[prop];\n                    return [ruleName, []];\n                }\n            }\n        }\n\n        const ruleAttributes = parseRuleAttribute(elem.getAttribute('data-vx-rule'));\n\n        for (let ruleName of Object.keys(ruleAttributes)) {\n            if (!_rules[ruleName] || !_rules[ruleName].validate) {\n                console.error(`undefined rule.validate \"${ruleName}\"`);\n                continue;\n            }\n            const ruleArgs = ruleAttributes[ruleName];\n            const ok = _rules[ruleName].validate(elem, ...ruleArgs);\n            if (ok) {\n                continue;\n            }\n\n            return [ruleName, ruleArgs];\n        }\n\n        return [null, []];\n    }\n\n    function format(elem, ruleName, ruleArgs, message) {\n\n        if (typeof message === 'function') {\n            return message(elem, ...ruleArgs);\n        }\n\n        if (ruleArgs.length === 0) {\n            return message;\n        }\n\n        const params = {};\n\n        ruleArgs.forEach((v, i) => {\n            if (ruleArgs[i] !== undefined) {\n                params[i] = ruleArgs[i];\n            }\n        });\n\n        if (_rules[ruleName] && _rules[ruleName].params) {\n            _rules[ruleName].params.forEach((v, i) => {\n                if (ruleArgs[i] !== undefined) {\n                    params[v] = ruleArgs[i];\n                }\n            });\n        }\n\n        return message.replace(/\\${(\\w+)}/g, (str, tag)=>{\n            if (params.hasOwnProperty(tag)) {\n                return params[tag];\n            }\n            return str;\n        });\n    }\n\n    function validate(elem) {\n\n        const [ruleName, args] = execute(elem);\n        if (!ruleName) {\n            return '';\n        }\n\n        const messages = parseMessageAttribute(elem.getAttribute('data-vx-message'));\n        const message = messages[ruleName] || _rules[ruleName].message || `error:${ruleName}`;\n        return format(elem, ruleName, args, message);\n    }\n\n    return {\n        rule,\n        validate,\n    };\n}());\n"]}